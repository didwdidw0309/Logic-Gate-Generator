/*
 * Copyright (c) 2015 NFL
 * Copyrights licensed under the MIT License.
 * See the accompanying LICENSE file for terms.
 */

import React from 'react';
import deepEqual from 'deep-equal';
export { default as deepEqual } from 'deep-equal';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var ATTRIBUTE_NAMES = {
    BODY: "bodyAttributes",
    HTML: "htmlAttributes",
    TITLE: "titleAttributes"
};

var HEAD_TAG_NAMES = {
    BASE: "base",
    LINK: "link",
    META: "meta",
    NOSCRIPT: "noscript",
    SCRIPT: "script",
    STYLE: "style",
    TITLE: "title"
};

var TAG_NAMES = _extends({
    BODY: "body",
    HEAD: "head",
    HTML: "html"
}, HEAD_TAG_NAMES);

var VALID_TAG_NAMES = Object.keys(TAG_NAMES).map(function (name) {
    return TAG_NAMES[name];
}).sort();

var TAG_PROPERTIES = {
    CHARSET: "charset",
    CSS_TEXT: "cssText",
    HREF: "href",
    HTTPEQUIV: "http-equiv",
    INNER_HTML: "innerHTML",
    ITEM_PROP: "itemprop",
    NAME: "name",
    PROPERTY: "property",
    REL: "rel",
    SRC: "src"
};

var REACT_TAG_MAP = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
};

var HELMET_PROPS = {
    DEFAULT_TITLE: "defaultTitle",
    DEFER: "defer",
    ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
    ON_CHANGE_CLIENT_STATE: "onChangeClientState",
    TITLE_TEMPLATE: "titleTemplate"
};

var HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function (obj, key) {
    obj[REACT_TAG_MAP[key]] = key;
    return obj;
}, {});

var SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];

var HELMET_IGNORE_ATTRIBUTE = "data-ignore-metadata";

var getTitleFromPropsList = function getTitleFromPropsList(propsList) {
    var innermostTitle = getInnermostProperty(propsList, TAG_NAMES.TITLE);
    var innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);

    if (innermostTemplate && innermostTitle) {
        // use function arg to avoid need to escape $ characters
        return innermostTemplate.replace(/%s/g, function () {
            return innermostTitle;
        });
    }

    var innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);

    return innermostTitle || innermostDefaultTitle || undefined;
};

var getOnChangeClientState = function getOnChangeClientState(propsList) {
    return getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || function () {};
};

var getAttributesFromPropsList = function getAttributesFromPropsList(tagType, propsList) {
    return propsList.filter(function (props) {
        return typeof props[tagType] !== "undefined";
    }).map(function (props) {
        return props[tagType];
    }).reduce(function (tagAttrs, current) {
        return _extends({}, tagAttrs, current);
    }, {});
};

var getBaseTagFromPropsList = function getBaseTagFromPropsList(primaryAttributes, propsList) {
    return propsList.filter(function (props) {
        return typeof props[TAG_NAMES.BASE] !== "undefined";
    }).map(function (props) {
        return props[TAG_NAMES.BASE];
    }).reverse().reduce(function (innermostBaseTag, tag) {
        if (!innermostBaseTag.length) {
            var keys = Object.keys(tag);

            for (var i = 0; i < keys.length; i++) {
                var attributeKey = keys[i];
                var lowerCaseAttributeKey = attributeKey.toLowerCase();

                if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
                    return innermostBaseTag.concat(tag);
                }
            }
        }

        return innermostBaseTag;
    }, []);
};

var getTagsFromPropsList = function getTagsFromPropsList(tagName, primaryAttributes, propsList) {
    // Calculate list of tags, giving priority innermost component (end of the propslist)
    var approvedSeenTags = {};

    return propsList.filter(function (props) {
        if (Array.isArray(props[tagName])) {
            return true;
        }
        if (typeof props[tagName] !== "undefined") {
            warn("Helmet: " + tagName + " should be of type \"Array\". Instead found type \"" + _typeof(props[tagName]) + "\"");
        }
        return false;
    }).map(function (props) {
        return props[tagName];
    }).reverse().reduce(function (approvedTags, instanceTags) {
        var instanceSeenTags = {};

        instanceTags.filter(function (tag) {
            var primaryAttributeKey = void 0;
            var keys = Object.keys(tag);
            for (var i = 0; i < keys.length; i++) {
                var attributeKey = keys[i];
                var lowerCaseAttributeKey = attributeKey.toLowerCase();

                // Special rule with link tags, since rel and href are both primary tags, rel takes priority
                if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === TAG_PROPERTIES.REL && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === TAG_PROPERTIES.REL && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
                    primaryAttributeKey = lowerCaseAttributeKey;
                }
                // Special case for innerHTML which doesn't work lowercased
                if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === TAG_PROPERTIES.INNER_HTML || attributeKey === TAG_PROPERTIES.CSS_TEXT || attributeKey === TAG_PROPERTIES.ITEM_PROP)) {
                    primaryAttributeKey = attributeKey;
                }
            }

            if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
                return false;
            }

            var value = tag[primaryAttributeKey].toLowerCase();

            if (!approvedSeenTags[primaryAttributeKey]) {
                approvedSeenTags[primaryAttributeKey] = {};
            }

            if (!instanceSeenTags[primaryAttributeKey]) {
                instanceSeenTags[primaryAttributeKey] = {};
            }

            if (!approvedSeenTags[primaryAttributeKey][value]) {
                instanceSeenTags[primaryAttributeKey][value] = true;
                return true;
            }

            return false;
        }).reverse().forEach(function (tag) {
            return approvedTags.push(tag);
        });

        // Update seen tags with tags from this instance
        var keys = Object.keys(instanceSeenTags);
        for (var i = 0; i < keys.length; i++) {
            var attributeKey = keys[i];
            var tagUnion = Object.assign({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);

            approvedSeenTags[attributeKey] = tagUnion;
        }

        return approvedTags;
    }, []).reverse();
};

var getInnermostProperty = function getInnermostProperty(propsList, property) {
    for (var i = propsList.length - 1; i >= 0; i--) {
        var props = propsList[i];

        if (props.hasOwnProperty(property)) {
            return props[property];
        }
    }

    return null;
};

var reducePropsToAttributes = function reducePropsToAttributes(propsList) {
    return {
        htmlAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.HTML, propsList),
        bodyAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.BODY, propsList)
    };
};

var reducePropsToHead = function reducePropsToHead(propsList) {
    return {
        baseTag: getBaseTagFromPropsList([TAG_PROPERTIES.HREF], propsList),
        linkTags: getTagsFromPropsList(TAG_NAMES.LINK, [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF], propsList),
        metaTags: getTagsFromPropsList(TAG_NAMES.META, [TAG_PROPERTIES.NAME, TAG_PROPERTIES.CHARSET, TAG_PROPERTIES.HTTPEQUIV, TAG_PROPERTIES.PROPERTY, TAG_PROPERTIES.ITEM_PROP], propsList),
        noscriptTags: getTagsFromPropsList(TAG_NAMES.NOSCRIPT, [TAG_PROPERTIES.INNER_HTML], propsList),
        scriptTags: getTagsFromPropsList(TAG_NAMES.SCRIPT, [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML], propsList),
        styleTags: getTagsFromPropsList(TAG_NAMES.STYLE, [TAG_PROPERTIES.CSS_TEXT], propsList),
        title: getTitleFromPropsList(propsList),
        titleAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.TITLE, propsList)
    };
};

var reducePropsToOpts = function reducePropsToOpts(propsList) {
    return {
        defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
        encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
        onChangeClientState: getOnChangeClientState(propsList)
    };
};

var reducePropsToState = function reducePropsToState(propsList, tagTypes) {
    if (tagTypes === "attr") {
        return reducePropsToAttributes(propsList);
    }

    if (tagTypes === "head") {
        return reducePropsToHead(propsList);
    }

    return Object.assign({}, reducePropsToAttributes(propsList), reducePropsToHead(propsList), reducePropsToOpts(propsList));
};

var generateTagsAsReactComponent = function generateTagsAsReactComponent(type, tags) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return tags.map(function (tag, i) {
        var mappedTag = {
            key: i
        };

        Object.keys(tag).forEach(function (attribute) {
            var mappedAttribute = REACT_TAG_MAP[attribute] || attribute;

            if (mappedAttribute === TAG_PROPERTIES.INNER_HTML || mappedAttribute === TAG_PROPERTIES.CSS_TEXT) {
                var content = tag.innerHTML || tag.cssText;
                mappedTag.dangerouslySetInnerHTML = { __html: content };
            } else {
                mappedTag[mappedAttribute] = tag[attribute];
            }
        });

        if (options[type]) {
            var _options$type = options[type],
                component = _options$type.component,
                props = _options$type.props;

            mappedTag = _extends({}, props, mappedTag);
            type = component || type;
        }

        return React.createElement(type, mappedTag);
    });
};

var convertElementAttributestoReactProps = function convertElementAttributestoReactProps(attributes) {
    var initProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return Object.keys(attributes).reduce(function (obj, key) {
        obj[REACT_TAG_MAP[key] || key] = attributes[key];
        return obj;
    }, initProps);
};

var generateTitleAsReactComponent = function generateTitleAsReactComponent(type, title, attributes) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    // assigning into an array to define toString function on it
    var initProps = {
        key: title
    };

    var props = convertElementAttributestoReactProps(attributes, initProps);

    if (options[type]) {
        var _options$type2 = options[type],
            component = _options$type2.component,
            _options$type2$props = _options$type2.props,
            typeComponentProps = _options$type2$props === undefined ? {} : _options$type2$props;

        props = _extends({}, props, typeComponentProps);
        type = component || type;
    }

    return [React.createElement(type, props, title)];
};

var warn = function warn(msg) {
    return console && typeof console.warn === "function" && console.warn(msg);
};

var updateAttributes = function updateAttributes(tagName, attributes) {
    var elementTag = document.getElementsByTagName(tagName)[0];

    if (!elementTag) {
        return;
    }

    // Determine if any attributes need to be ignored
    var helmetIgnoreAttributeString = elementTag.getAttribute(HELMET_IGNORE_ATTRIBUTE);
    var helmetIgnoreAttributes = helmetIgnoreAttributeString ? helmetIgnoreAttributeString.split(",") : [];

    // Determine existing attributes
    var helmetAttributes = [];
    if (elementTag.hasAttributes()) {
        var attrs = elementTag.attributes;
        for (var i = attrs.length - 1; i >= 0; i--) {
            if (helmetIgnoreAttributes.indexOf(attrs[i].name) === -1) {
                helmetAttributes.push(attrs[i].name); // attrs[i].value
            }
        }
    }
    var attributesToRemove = [].concat(helmetAttributes);
    var attributeKeys = Object.keys(attributes);

    for (var _i = 0; _i < attributeKeys.length; _i++) {
        var attribute = attributeKeys[_i];
        var value = attributes[attribute] || "";

        if (elementTag.getAttribute(attribute) !== value) {
            elementTag.setAttribute(attribute, value);
        }

        if (helmetAttributes.indexOf(attribute) === -1) {
            helmetAttributes.push(attribute);
        }

        var indexToSave = attributesToRemove.indexOf(attribute);
        if (indexToSave !== -1) {
            attributesToRemove.splice(indexToSave, 1);
        }
    }

    for (var _i2 = attributesToRemove.length - 1; _i2 >= 0; _i2--) {
        elementTag.removeAttribute(attributesToRemove[_i2]);
    }
};

var getComponentForTag = function getComponentForTag(type, tags, options) {
    switch (type) {
        case HEAD_TAG_NAMES.TITLE:
            return generateTitleAsReactComponent(type, tags.title, tags.titleAttributes, options);
        case ATTRIBUTE_NAMES.BODY:
        case ATTRIBUTE_NAMES.HTML:
            return convertElementAttributestoReactProps(tags);
        default:
            return generateTagsAsReactComponent(type, tags, options);
    }
};

var mapStateToAttributes = function mapStateToAttributes(_ref, componentOptions) {
    var bodyAttributes = _ref.bodyAttributes,
        htmlAttributes = _ref.htmlAttributes;

    var components = {
        bodyAttributes: [],
        htmlAttributes: []
    };

    if (bodyAttributes) {
        components.bodyAttributes = getComponentForTag(ATTRIBUTE_NAMES.BODY, bodyAttributes, componentOptions);
    }

    if (htmlAttributes) {
        components.htmlAttributes = getComponentForTag(ATTRIBUTE_NAMES.HTML, htmlAttributes, componentOptions);
    }

    return components;
};

var mapStateToHead = function mapStateToHead(_ref2, componentOptions) {
    var baseTag = _ref2.baseTag,
        linkTags = _ref2.linkTags,
        metaTags = _ref2.metaTags,
        noscriptTags = _ref2.noscriptTags,
        scriptTags = _ref2.scriptTags,
        styleTags = _ref2.styleTags,
        title = _ref2.title,
        titleAttributes = _ref2.titleAttributes;

    var components = {
        base: [],
        link: [],
        meta: [],
        noscript: [],
        script: [],
        style: [],
        title: []
    };

    if (baseTag) {
        components.base = getComponentForTag(HEAD_TAG_NAMES.BASE, baseTag, componentOptions);
    }

    if (linkTags) {
        components.link = getComponentForTag(HEAD_TAG_NAMES.LINK, linkTags, componentOptions);
    }

    if (metaTags) {
        components.meta = getComponentForTag(HEAD_TAG_NAMES.META, metaTags, componentOptions);
    }

    if (noscriptTags) {
        components.noscript = getComponentForTag(HEAD_TAG_NAMES.NOSCRIPT, noscriptTags, componentOptions);
    }

    if (scriptTags) {
        components.script = getComponentForTag(HEAD_TAG_NAMES.SCRIPT, scriptTags, componentOptions);
    }

    if (styleTags) {
        components.style = getComponentForTag(HEAD_TAG_NAMES.STYLE, styleTags, componentOptions);
    }

    if (title) {
        components.title = getComponentForTag(HEAD_TAG_NAMES.TITLE, { title: title || "", titleAttributes: titleAttributes }, componentOptions);
    }

    return components;
};

var mapStateToComponents = function mapStateToComponents(state, options) {
    return Object.assign(mapStateToAttributes(state, options), mapStateToHead(state, options));
};

var renderAttributes = function renderAttributes(_ref3) {
    var htmlAttributes = _ref3.htmlAttributes,
        bodyAttributes = _ref3.bodyAttributes;

    updateAttributes(TAG_NAMES.BODY, bodyAttributes);
    updateAttributes(TAG_NAMES.HTML, htmlAttributes);
};

export { reducePropsToState, mapStateToComponents, mapStateToAttributes, mapStateToHead, renderAttributes, HEAD_TAG_NAMES };
