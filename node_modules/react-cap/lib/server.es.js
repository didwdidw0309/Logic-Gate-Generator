/*
 * Copyright (c) 2015 NFL
 * Copyrights licensed under the MIT License.
 * See the accompanying LICENSE file for terms.
 */

import React from 'react';

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var ATTRIBUTE_NAMES = {
    BODY: "bodyAttributes",
    HTML: "htmlAttributes",
    TITLE: "titleAttributes"
};

var HEAD_TAG_NAMES = {
    BASE: "base",
    LINK: "link",
    META: "meta",
    NOSCRIPT: "noscript",
    SCRIPT: "script",
    STYLE: "style",
    TITLE: "title"
};

var TAG_NAMES = _extends({
    BODY: "body",
    HEAD: "head",
    HTML: "html"
}, HEAD_TAG_NAMES);

var VALID_TAG_NAMES = Object.keys(TAG_NAMES).map(function (name) {
    return TAG_NAMES[name];
}).sort();

var TAG_PROPERTIES = {
    CHARSET: "charset",
    CSS_TEXT: "cssText",
    HREF: "href",
    HTTPEQUIV: "http-equiv",
    INNER_HTML: "innerHTML",
    ITEM_PROP: "itemprop",
    NAME: "name",
    PROPERTY: "property",
    REL: "rel",
    SRC: "src"
};

var REACT_TAG_MAP = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
};

var HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function (obj, key) {
    obj[REACT_TAG_MAP[key]] = key;
    return obj;
}, {});

var SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];

var generateTagsAsReactComponent = function generateTagsAsReactComponent(type, tags) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return tags.map(function (tag, i) {
        var mappedTag = {
            key: i
        };

        Object.keys(tag).forEach(function (attribute) {
            var mappedAttribute = REACT_TAG_MAP[attribute] || attribute;

            if (mappedAttribute === TAG_PROPERTIES.INNER_HTML || mappedAttribute === TAG_PROPERTIES.CSS_TEXT) {
                var content = tag.innerHTML || tag.cssText;
                mappedTag.dangerouslySetInnerHTML = { __html: content };
            } else {
                mappedTag[mappedAttribute] = tag[attribute];
            }
        });

        if (options[type]) {
            var _options$type = options[type],
                component = _options$type.component,
                props = _options$type.props;

            mappedTag = _extends({}, props, mappedTag);
            type = component || type;
        }

        return React.createElement(type, mappedTag);
    });
};

var convertElementAttributestoReactProps = function convertElementAttributestoReactProps(attributes) {
    var initProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return Object.keys(attributes).reduce(function (obj, key) {
        obj[REACT_TAG_MAP[key] || key] = attributes[key];
        return obj;
    }, initProps);
};

var generateTitleAsReactComponent = function generateTitleAsReactComponent(type, title, attributes) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    // assigning into an array to define toString function on it
    var initProps = {
        key: title
    };

    var props = convertElementAttributestoReactProps(attributes, initProps);

    if (options[type]) {
        var _options$type2 = options[type],
            component = _options$type2.component,
            _options$type2$props = _options$type2.props,
            typeComponentProps = _options$type2$props === undefined ? {} : _options$type2$props;

        props = _extends({}, props, typeComponentProps);
        type = component || type;
    }

    return [React.createElement(type, props, title)];
};

var flattenArray = function flattenArray(possibleArray) {
    return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
};

var encodeSpecialCharacters = function encodeSpecialCharacters(str) {
    var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (encode === false) {
        return String(str);
    }

    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};

var generateElementAttributesAsString = function generateElementAttributesAsString(attributes) {
    return Object.keys(attributes).reduce(function (str, key) {
        var attr = typeof attributes[key] !== "undefined" ? key + "=\"" + attributes[key] + "\"" : "" + key;
        return str ? str + " " + attr : attr;
    }, "");
};

var generateTitleAsString = function generateTitleAsString(type, title, attributes, encode) {
    var attributeString = generateElementAttributesAsString(attributes);
    var flattenedTitle = flattenArray(title);
    return attributeString ? "<" + type + " " + attributeString + ">" + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">" : "<" + type + ">" + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">";
};

var generateTagsAsString = function generateTagsAsString(type, tags, encode) {
    return tags.reduce(function (str, tag) {
        var attributeHtml = Object.keys(tag).filter(function (attribute) {
            return !(attribute === TAG_PROPERTIES.INNER_HTML || attribute === TAG_PROPERTIES.CSS_TEXT);
        }).reduce(function (string, attribute) {
            var attr = typeof tag[attribute] === "undefined" ? attribute : attribute + "=\"" + encodeSpecialCharacters(tag[attribute], encode) + "\"";
            return string ? string + " " + attr : attr;
        }, "");

        var tagContent = tag.innerHTML || tag.cssText || "";

        var isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;

        return str + "<" + type + " " + attributeHtml + (isSelfClosing ? "/>" : ">" + tagContent + "</" + type + ">");
    }, "");
};

var getMethodsForTag = function getMethodsForTag(type, tags, encode, componentOptions) {
    switch (type) {
        case TAG_NAMES.TITLE:
            return {
                toComponent: function toComponent() {
                    return generateTitleAsReactComponent(type, tags.title, tags.titleAttributes, componentOptions);
                },
                toString: function toString() {
                    return generateTitleAsString(type, tags.title, tags.titleAttributes, encode);
                }
            };
        case ATTRIBUTE_NAMES.BODY:
        case ATTRIBUTE_NAMES.HTML:
            return {
                toComponent: function toComponent() {
                    return convertElementAttributestoReactProps(tags);
                },
                toString: function toString() {
                    return generateElementAttributesAsString(tags);
                }
            };
        default:
            return {
                toComponent: function toComponent() {
                    return generateTagsAsReactComponent(type, tags, componentOptions);
                },
                toString: function toString() {
                    return generateTagsAsString(type, tags, encode);
                }
            };
    }
};

var mapStateOnServer = function mapStateOnServer(state) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return Object.assign(mapAttributeStateOnServer(state, options), mapComponentStateOnServer(state, options));
};

var mapComponentStateOnServer = function mapComponentStateOnServer(_ref) {
    var baseTag = _ref.baseTag,
        bodyAttributes = _ref.bodyAttributes,
        encode = _ref.encode,
        htmlAttributes = _ref.htmlAttributes,
        linkTags = _ref.linkTags,
        metaTags = _ref.metaTags,
        noscriptTags = _ref.noscriptTags,
        scriptTags = _ref.scriptTags,
        styleTags = _ref.styleTags,
        _ref$title = _ref.title,
        title = _ref$title === undefined ? "" : _ref$title,
        titleAttributes = _ref.titleAttributes;
    var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return {
        base: getMethodsForTag(TAG_NAMES.BASE, baseTag, encode, componentOptions),
        link: getMethodsForTag(TAG_NAMES.LINK, linkTags, encode, componentOptions),
        meta: getMethodsForTag(TAG_NAMES.META, metaTags, encode, componentOptions),
        noscript: getMethodsForTag(TAG_NAMES.NOSCRIPT, noscriptTags, encode, componentOptions),
        script: getMethodsForTag(TAG_NAMES.SCRIPT, scriptTags, encode, componentOptions),
        style: getMethodsForTag(TAG_NAMES.STYLE, styleTags, encode, componentOptions),
        title: getMethodsForTag(TAG_NAMES.TITLE, { title: title, titleAttributes: titleAttributes }, encode, componentOptions)
    };
};

var mapAttributeStateOnServer = function mapAttributeStateOnServer(_ref2) {
    var bodyAttributes = _ref2.bodyAttributes,
        encode = _ref2.encode,
        htmlAttributes = _ref2.htmlAttributes;
    var componentOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return {
        bodyAttributes: getMethodsForTag(ATTRIBUTE_NAMES.BODY, bodyAttributes, encode, componentOptions),
        htmlAttributes: getMethodsForTag(ATTRIBUTE_NAMES.HTML, htmlAttributes, encode, componentOptions)
    };
};

export { mapStateOnServer, mapAttributeStateOnServer, mapComponentStateOnServer, generateElementAttributesAsString };
