'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _exenv = require('exenv');

var _exenv2 = _interopRequireDefault(_exenv);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _reactScriptTag = require('react-script-tag');

var _reactScriptTag2 = _interopRequireDefault(_reactScriptTag);

var _CapUtils = require('react-cap/lib/CapUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IS_DEV = process.env.NODE_ENV !== 'production';

var Metadata = function () {

    /**
     * Create a new metadata instance.
     *
     * @param md [Object] optionally, assign initial metadata
     * @returns {Metadata}
     * @public
     */
    Metadata.createNew = function createNew(md) {
        return new Metadata(false, false, typeof md !== 'undefined' ? [md] : []);
    };

    /**
     * Create a new metadata instance for hydrating the client render.
     * @param state
     * @returns {Metadata}
     * @public
     */


    // Expose for testing


    Metadata.createForHydration = function createForHydration(state) {
        return new Metadata(true, false, state);
    };

    /**
     * Create a new metadata instance to load metadata before the react render lifecycle for SSR with streams.
     * @param state
     * @returns {Metadata}
     * @public
     */


    Metadata.createForServerStreamRender = function createForServerStreamRender(state) {
        return new Metadata(false, true, state);
    };

    /**
     * Creates a new Metadata instance.
     *
     * @param isHydrating
     * @param isServerStreamRender
     * @param state
     * @private
     */


    function Metadata(isHydrating, isServerStreamRender) {
        var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        (0, _classCallCheck3.default)(this, Metadata);

        if (typeof state !== 'undefined') {
            (0, _invariant2.default)(Array.isArray(state), 'Metadata expects the optional state parameter to be an array.');
        }

        this._isHydratingClient = isHydrating;
        this._isServerStreamRender = isServerStreamRender;
        this._metadataList = state.slice();
        this._hydrationMark = -1;
        this._onChangeSubscribers = [];
    }

    /**
     * Returns the internal metadata state.
     *
     * This can be used to pass server rendered metadata to the client render.
     *
     * @returns {Array.<Object>} internal metadata state.
     * @public
     */


    Metadata.prototype.getState = function getState() {
        return this._metadataList.slice();
    };

    Metadata.prototype.markHydrated = function markHydrated() {
        if (this._metadataList.length > 0 && this._hydrationMark === -1) {
            this._hydrationMark = this._metadataList.length;
        }
    };

    Metadata.prototype.isMounted = function isMounted() {
        if (this.isHydratingClient()) {
            // prevents re-loading data on initial client render when data was rendered on server
            this._isHydratingClient = false;

            if (this._hydrationMark > 0) {
                // Delete any hydrated metadata entries after the initial render is complete
                this._metadataList.splice(0, this._hydrationMark);
            }

            // update the metadata - this should resolve to the initial server render
            this._hydrationMark = -1;
            this.updateMetadata();
        }
    };

    Metadata.prototype.appendMetadata = function appendMetadata(metadata) {
        if (metadata === null) {
            return;
        }

        this._metadataList.push(metadata);
    };

    Metadata.prototype.getHelmetState = function getHelmetState() {
        return (0, _CapUtils.reducePropsToState)(this.getState());
    };

    Metadata.prototype.getComponents = function getComponents() {
        return (0, _CapUtils.mapStateToComponents)((0, _extends3.default)({}, this.getHelmetState(), {
            typeComponents: {
                script: {
                    component: _reactScriptTag2.default,
                    props: {
                        isHydrating: this._isHydratingClient
                    }
                }
            }
        }));
    };

    Metadata.prototype.updateMetadata = function updateMetadata() {
        var self = this;
        self._onChangeSubscribers.forEach(function (subscriber) {
            return subscriber(self);
        });
    };

    /**
     * Updates the current metadata state
     *
     * @param previousMetadata will be removed if different from the new metadata
     * @param newMetadata will be appended if its non null
     * @returns {*} the applied metadata instance
     */


    Metadata.prototype.update = function update(previousMetadata, newMetadata) {
        if (this.isServerRender()) {
            // don't update on initial client render or on the server render.
            return null;
        }

        if ((0, _CapUtils.deepEqual)(previousMetadata, newMetadata)) {
            // Nothing to update
            return previousMetadata;
        }

        // Support persisting metadata, so its NEVER removed
        if (newMetadata && newMetadata.persist === true) {
            for (var i = 0, len = this._metadataList.length; i < len; i++) {
                var item = this._metadataList[i];
                if (item.persist !== true) {
                    continue;
                }

                if ((0, _CapUtils.deepEqual)(item, newMetadata)) {
                    // Metadata already exists
                    return previousMetadata;
                }
            }
        }

        if (this.isHydratingClient()) {
            // append the metadata - will be applied once initial render is complete
            this.appendMetadata(newMetadata);
            return newMetadata;
        }

        // Remove the previous metadata
        if (previousMetadata !== null) {
            var index = this._metadataList.indexOf(previousMetadata);
            if (index !== -1) {
                // Prevent persisted metadata from being removed
                if (this._metadataList[index].persist !== true) {
                    this._metadataList.splice(index, 1);
                }
            } else if (IS_DEV) {
                // eslint-disable-next-line no-console
                console.warn('Failed to remove HTML metadata item at index ' + index + '.');
            }
        }

        // Update the metadata in the HTML document
        this.appendMetadata(newMetadata);
        this.updateMetadata();
        return newMetadata;
    };

    /**
     * Subscribe to be notified when metadata changes. Be sure to unsubscribe to prevent memory leaks.
     *
     * @param callback
     * @returns {unsubscribe}
     */


    Metadata.prototype.onChange = function onChange(callback) {
        var self = this;
        self._onChangeSubscribers.push(callback);

        return function unsubscribe() {
            var idx = self._onChangeSubscribers.indexOf(callback);
            if (idx > -1) {
                self._onChangeSubscribers.splice(idx, 1);
            }
        };
    };

    Metadata.prototype.isHydratingClient = function isHydratingClient() {
        return this._isHydratingClient === true;
    };

    Metadata.prototype.isServerRender = function isServerRender() {
        return Metadata.canUseDOM !== true;
    };

    Metadata.prototype.isServerStreamRender = function isServerStreamRender() {
        return this._isServerStreamRender && this.isServerRender();
    };

    return Metadata;
}();

Metadata.canUseDOM = _exenv2.default.canUseDOM;
exports.default = Metadata;